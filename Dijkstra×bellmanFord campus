#include <stdio.h>
#include <limits.h>

#define V 6
#define INF INT_MAX

const char *location_names[V] = {
    "Admission Office",
    "AB-4",
    "Gym",
    "Medical Center",
    "Food Court",
    "YKSG-2"
};

void print_result(int dist[]) {
    for (int i = 0; i < V; i++) {
        if (dist[i] == INF)
            printf("  To %s (Node %d): INF\n", location_names[i], i);
        else
            printf("  To %s (Node %d): %d\n", location_names[i], i, dist[i]);
    }
}

void dijkstra(int graph[V][V], int src) {
    int dist[V], visited[V];
    for (int i = 0; i < V; i++) {
        dist[i] = INF;
        visited[i] = 0;
    }
    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int min = INF, u = -1;
        for (int v = 0; v < V; v++)
            if (!visited[v] && dist[v] <= min) {
                min = dist[v];
                u = v;
            }
        if (u == -1) break;
        visited[u] = 1;

        for (int v = 0; v < V; v++)
            if (!visited[v] && graph[u][v] != INF && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }
    print_result(dist);
}

struct Edge {
    int src, dest, weight;
};

int bellman_ford(struct Edge edges[], int edgeCount, int src) {
    int dist[V];
    for (int i = 0; i < V; i++)
        dist[i] = INF;
    dist[src] = 0;

    for (int i = 1; i <= V - 1; i++) {
        for (int j = 0; j < edgeCount; j++) {
            int u = edges[j].src;
            int v = edges[j].dest;
            int wt = edges[j].weight;
            if (dist[u] != INF && dist[u] + wt < dist[v])
                dist[v] = dist[u] + wt;
        }
    }

    for (int j = 0; j < edgeCount; j++) {
        int u = edges[j].src;
        int v = edges[j].dest;
        int wt = edges[j].weight;
        if (dist[u] != INF && dist[u] + wt < dist[v]) {
            printf("  Graph contains a negative weight cycle.\n");
            return 1;
        }
    }
    print_result(dist);
    return 0;
}

int main() {
    int graph[V][V];
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++)
            graph[i][j] = INF;

    graph[0][1] = 3;
    graph[0][2] = 5;
    graph[1][3] = 4;
    graph[1][2] = 2;
    graph[2][3] = 1;
    graph[3][4] = 6;
    graph[4][5] = 8;

    printf("Dijkstra's Shortest Paths (Source: %s):\n", location_names[0]);
    dijkstra(graph, 0);

    struct Edge edges_bellman[] = {
        {0, 1, 3},
        {0, 2, 5},
        {1, 3, 4},
        {1, 2, -2},
        {2, 3, 1},
        {3, 4, 6},
        {4, 5, 8}
    };
    int edgeCount_bellman = sizeof(edges_bellman) / sizeof(edges_bellman[0]);

    printf("\nBellman-Ford Shortest Paths (Source: %s):\n", location_names[0]);
    bellman_ford(edges_bellman, edgeCount_bellman, 0);

    struct Edge edges_negative_cycle[] = {
        {0, 1, 1},
        {1, 2, -1},
        {2, 3, -1},
        {3, 1, -1}
    };
    int negCount = sizeof(edges_negative_cycle) / sizeof(edges_negative_cycle[0]);

    printf("\nBellman-Ford with a Negative Cycle (Source: %s):\n", location_names[0]);
    bellman_ford(edges_negative_cycle, negCount, 0);

    return 0;
}
